---
title: V8 是如何进行正则表达式匹配的
date: 2025-07-16 00:20
excerpt: TODO
category: 前端
mermaid: true
---
# 背景
最近在写油猴脚本，遇到需要大量进行正则表达式匹配的场景，因为油猴脚本在用户端运行，所以希望能扣一点性能出来，哪怕能节约 1 ms 也是好的

这里就有一个优化场景：`new RegExp(/a/).test('abc')` 和 `new RegExp(/abc/).test('abc')` 都会返回 `true`，那么是否需要用开发者的先验，尽量在正则表达式中提供更多的信息，节约匹配时的计算量？

然后就想到 [leetcode 中做过正则表达式匹配的题](https://leetcode.cn/problems/regular-expression-matching/)，但只是 `.` 和 `*` 的简单场景，正好研究一下生产环境中实际的正则表达式匹配是怎么做的

**文本仅讨论 V8 中高级语言对正则表达式匹配的处理，不涉及编译、解释以及其他更底层的优化**

# 源代码
## 位置
为了简单起见，就只研究 Chrome（V8 engine）的实现了

V8 的相关代码可以在[官方仓库](https://chromium.googlesource.com/v8/v8.git)和 [GitHub 镜像](https://github.com/v8/v8)中访问

正则表达式匹配相关的代码，主要在 `src/builtins` 下，`regexp-test.tq` 作为最初的入口

`.tq` 表示这是 V8 Torque 语言编写的代码，V8 Torque 是一种内部使用的专用语言，在编写 builtins（包括 JavaScript 标准内置对象、方法和函数的实现）时，主要使用 Torque

[Torque](https://v8.dev/docs/torque) 在语法上接近 C++ 和 Typescript，可以转换为 [CodeStubAssembler](https://v8.dev/blog/csa)。使用 Torque 编写 builtins，相对于使用 C++ 和 JavaScript 有一些优点（这并不是说 [builtins](https://v8.dev/docs/builtin-functions) 全部是 Torque 编写的，这里有一些[权衡](https://v8.dev/docs/torque-builtins#:~:text=V8%E2%80%99s%20builtins%20can%20be%20implemented%20using%20a%20number%20of%20different%20methods%20(each%20with%20different%20trade%2Doffs)%3A)）

本文的版本基于 V8 13.5，因为 V8 对于正则表达式的处理也是会发生很大变化的，比如[从基于 PCRE 到基于 Irregexp](https://blog.chromium.org/2009/02/irregexp-google-chromes-new-regexp.html)，[从 JavaScript 实现迁移到基于 TurboFan 的新实现](https://v8.dev/blog/speeding-up-regular-expressions)，[非回溯 RegExp 引擎](https://v8.dev/blog/non-backtracking-regexp)，所以这篇文章仅仅基于 V8 在 20250205 的版本

## 逻辑
对于 `RegExp.prototype.test()`，首先起点是 `RegExpPrototypeTest`，下面是函数的调用关系

{% mermaid %}
graph TD
    A(RegExpPrototypeTest) --> B{IsFastRegExpPermissive}
    B -- true --> C1(RegExpPrototypeExecBodyWithoutResultFast)
    B -- false --> G
    C1 --> D(RegExpPrototypeExecBodyWithoutResult)
    D --> E(RegExpExecInternal_Single)
    E --> F(RegExpExecInternal)
    F --> G(RegExpExec)
    G --> H(RegExp::Exec)
    H --> I{data->type_tag}
    I -- RegExpData::Type::ATOM --> J1(RegExpImpl::AtomExec)
    I -- RegExpData::Type::IRREGEXP --> J2(RegExpImpl::IrregexpExec)
    I -- RegExpData::Type::EXPERIMENTAL --> J3(ExperimentalRegExp::Exec)
    J2 --> K(IrregexpExecRaw)
    K --> L{regexp_data->ShouldProduceBytecode}
    L -- false --> M1(NativeRegExpMacroAssembler::Match)
    L -- true --> M2(IrregexpInterpreter::MatchForCallFromRuntime)
{% endmermaid %}

**暂时先烂尾在这里，去看看纯算法**

除了类型转换、各种检查、处理 flags 参数、初始化各种需要变量这种细枝末节，主要的逻辑是这样的：

首先判断正则表达式是否是 `FastRegExp`（代码在 `BranchIfFastRegExp` 中），标准如下：

- 对象本身未被修改
- 对象的原型 `RegExp.prototype` 未被修改
- 对象的 `lastIndex` 属性是非负数的小整数（Smi）

## 实现细节
### lastIndex 的条件
上面提到对 `lastIndex` 的判断，虽然函数名是 `TaggedIsPositiveSmi`，但是具体实现是提取 `lastIndex` 的标记位和 Smi 位，再和 `kSmiTagMask | kSmiSignMask` 进行按位与操作，然后和 0 比较

考虑到 0 和正数的 `kSmiSignMask` 是一样的，所以这里 `lastIndex` 是 0 也符合条件

### 一大堆离谱的宏
在 `RegExpExecInternal` 里，最终调用的是：
```c++
CallRuntime(Runtime::kRegExpExec, context, regexp, string, last_index, SmiFromInt32(result_offsets_vector_length))
```
而 `kRegExpExec` 是 `src/runtime/runtime.h` 中用一大堆宏展开产生的

宏展开的细节就不谈了，和 `kRegExpExec` 相关的内容是：

```c++
#define F(name, nargs, ressize) k##name,

#define FOR_EACH_INTRINSIC_REGEXP(F, I)             \
  F(RegExpBuildIndices, 3, 1)                       \
  F(RegExpGrowRegExpMatchInfo, 2, 1)                \
  F(RegExpExecMultiple, 3, 1)                       \
  F(RegExpInitializeAndCompile, 3, 1)               \
  F(RegExpMatchGlobalAtom, 3, 1)                    \
  F(RegExpReplaceRT, 3, 1)                          \
  F(RegExpSplit, 3, 1)                              \
  F(RegExpStringFromFlags, 1, 1)                    \
  F(StringReplaceNonGlobalRegExpWithFunction, 3, 1) \
  F(StringSplit, 3, 1)                              \
  F(RegExpExec, 4, 1)                               \
  F(RegExpExperimentalOneshotExec, 4, 1)
```

所以实际调用的函数的函数名是 `RegExpExec`

# TODO
先不研究实现细节了，研究一下算法